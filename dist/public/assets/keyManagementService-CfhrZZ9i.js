import{v as m,g as k,a as V,d as A,b as N,e as F,c as D,s as E,M as K,f as R,h as P,i as U}from"./index-6CtNGf6q.js";async function I(c,l,n,o){try{if(console.log("Starting key re-encryption process..."),o(0,"Validating current password..."),!c)throw console.error("Old password is empty or null"),new Error("Current password is required");if(!l)throw console.error("New password is empty or null"),new Error("New password is required");if(l.length<8)throw console.error("New password too short:",l.length),new Error("New password must be at least 8 characters long");if(!n)throw console.error("Email is empty or null"),new Error("User email is required for key re-encryption");if(console.log(`Validating password for user ${n}...`),!await _(c,n))throw console.error("Password validation failed"),new Error("Current password validation failed");console.log("Password validation successful"),o(10,"Unlocking vault system...");try{console.log("Attempting to unlock vault system..."),await m.unlockVault(c)?console.log("Vault successfully unlocked"):console.warn("No vault found or unable to unlock with current password")}catch(e){console.error("Error unlocking vault:",e)}let i=null;try{if(i=m.isUnlocked()?m.getStorageKey():null,i)console.log("Successfully retrieved storage key, length:",i.length);else return console.log("No storage key available - vault not created yet or locked"),o(100,"No vault data to update"),!0}catch(e){throw console.error("Error retrieving storage key:",e),new Error("Failed to access storage key: "+(e instanceof Error?e.message:String(e)))}o(20,"Loading master keys...");const p=`master_keys_${n.replace(/[^a-zA-Z0-9]/g,"_")}`;console.log(`Using master keys ID: ${p}`);let g=null;try{console.log("Attempting to load user-specific master keys..."),g=await k("masterKeys",p),g?console.log("Found user-specific master keys"):(console.log("No user-specific master keys found, checking legacy location"),g=await k("keys","masterKeys"),console.log(g?"Found master keys in legacy location":"No master keys found in either location"))}catch(e){console.error("Error retrieving master keys:",e)}o(30,"Gathering vaults for re-encryption...");let t=[];try{console.log("Loading all vaults from storage..."),t=await V("vaults"),console.log(`Found ${t.length} vaults to re-encrypt`);const e=t.filter(s=>s&&s.id&&s.encryptedKey&&s.encryptedMetadata);e.length<t.length&&(console.warn(`Found ${t.length-e.length} invalid vaults, filtering them out`),t=e);const r=`user_${n.replace(/[^a-zA-Z0-9]/g,"_")}`,a=t.filter(s=>s.id.startsWith(r));console.log(`Found ${a.length} vaults for current user`)}catch(e){console.error("Error retrieving vaults:",e),t=[]}const $=new Map,S=20/Math.max(t.length,1);let d=30;o(d,"Decrypting vault keys...");let h=0;for(let e=0;e<t.length;e++){const r=t[e];try{if(console.log(`Decrypting vault key for vault ${r.id}...`),!r.encryptedKey){console.error(`Vault ${r.id} has no encrypted key, skipping`);continue}if(!i){console.error(`No storage key available to decrypt vault ${r.id}, skipping`);continue}const a=await A(r,i);console.log(`Successfully decrypted key for vault ${r.id}`),a?$.set(r.id,a):(console.error(`Decrypted vault key is null for vault ${r.id}`),h++),d+=S,o(d,`Decrypted vault ${e+1} of ${t.length}...`)}catch(a){console.error(`Failed to decrypt vault ${r.id} for re-encryption:`,a),h++}}h>0&&console.warn(`Failed to decrypt ${h} out of ${t.length} vaults`),o(50,"Generating new encryption keys...");let y;try{console.log("Generating new derived key from new password..."),y=await N(l),console.log("Successfully derived new key",y?"✅":"❌")}catch(e){throw console.error("Failed to derive key from new password:",e),new Error("Failed to generate new encryption key: "+(e instanceof Error?e.message:String(e)))}let v;try{if(console.log("Encrypting storage key with new derived key..."),!i)throw new Error("Storage key is unavailable");v=await F(i,y.key),console.log("Successfully encrypted storage key with new password",v?"✅":"❌")}catch(e){throw console.error("Failed to encrypt storage key with new derived key:",e),new Error("Failed to re-encrypt storage key: "+(e instanceof Error?e.message:String(e)))}o(60,"Updating master keys...");try{if(console.log("Ensuring masterKeys store is properly initialized..."),!await D())throw console.error("Failed to initialize masterKeys store"),new Error("Database initialization error: masterKeys store not available");if(console.log("MasterKeys store verified, proceeding with key update"),g){console.log("Found existing master keys, re-encrypting with new password");const a={...{...g,encryptedStorageKey:v,salt:y.salt,rootKeyHash:y.hash},id:p};try{await E(K,a),console.log("Master keys updated successfully with new password")}catch(s){throw console.error("Error storing master keys:",s),new Error("Failed to store master keys in database: "+(s instanceof Error?s.message:String(s)))}!await k(K,p)&&await k("keys","masterKeys")&&(console.log("Removing legacy master keys after migration to user-specific storage"),await R("keys","masterKeys"))}else{console.log("No existing master keys found, creating new ones");const a={...{rootKeyHash:y.hash,encryptedStorageKey:v,salt:y.salt},id:p};try{await E(K,a),console.log("New master keys created successfully")}catch(s){throw console.error("Error storing new master keys:",s),new Error("Failed to create master keys in database: "+(s instanceof Error?s.message:String(s)))}}}catch(e){throw console.error("Failed to store updated master keys:",e),new Error("Failed to update master keys: "+(e instanceof Error?e.message:String(e)))}const M=30/Math.max(t.length,1);d=60,o(d,`Re-encrypting ${t.length} vaults...`);let f=0;for(let e=0;e<t.length;e++){const r=t[e];try{const a=$.get(r.id);if(console.log(`Re-encrypting vault ${r.id}...`),!a){console.warn(`No decrypted key available for vault ${r.id}, skipping re-encryption`),f++;continue}if(!i){console.error(`No storage key available to re-encrypt vault ${r.id}, skipping`),f++;continue}const s=await F(a,i);if(!s){console.error(`Failed to re-encrypt key for vault ${r.id} - result is null`),f++;continue}console.log(`Successfully re-encrypted key for vault ${r.id}`);const w={id:r.id,encryptedKey:s,encryptedMetadata:r.encryptedMetadata};r.type&&(w.type=r.type),r.owner&&(w.owner=r.owner),r.createdAt&&(w.createdAt=r.createdAt),r.updatedAt&&(w.updatedAt=r.updatedAt||Date.now()),await E("vaults",w),console.log(`Updated vault ${r.id} in storage`),d+=M,o(Math.min(d,90),`Re-encrypted vault ${e+1} of ${t.length}...`)}catch(a){console.error(`Failed to re-encrypt vault ${r.id}:`,a),f++}}return f>0&&console.warn(`Failed to re-encrypt ${f} out of ${t.length} vaults`),o(100,"Key re-encryption complete!"),console.log("Completed re-encryption of all keys"),!0}catch(u){throw console.error("Error during key re-encryption:",u),o(0,"Key re-encryption failed: "+(u instanceof Error?u.message:String(u))),u}}async function _(c,l){try{if(console.log(`Validating password for user ${l}...`),!c)return console.error("Empty password provided for validation"),!1;if(!l)return console.error("Empty email provided for validation"),!1;console.log("Retrieving user keys for validation...");const n=await P(l);if(!n)return console.error("User keys not found for email:",l),!1;if(console.log("User keys found, verifying password..."),!n.salt||!n.hash)return console.error("User keys missing salt or hash properties"),!1;console.log("Performing hash-based password verification...");try{if(!await U(c,n.salt,n.hash))return console.warn("Password hash verification failed"),!1;console.log("Password verified successfully via hash comparison")}catch(o){return console.error("Error during password hash verification:",o),!1}console.log("Attempting secondary verification via vault unlocking...");try{await m.unlockVault(c)?console.log("Successfully unlocked vault with password"):console.warn("Could not unlock vault with password, but hash verification passed")}catch(o){console.warn("Error trying to unlock vault:",o)}return console.log("Password validation complete and successful"),!0}catch(n){return console.error("Password validation error:",n),!1}}export{I as reEncryptAllKeys,_ as validatePassword};
